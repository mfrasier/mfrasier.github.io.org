<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Elasticsearch | Blog about things]]></title>
  <link href="http://mfrasier.github.io/blog/categories/elasticsearch/atom.xml" rel="self"/>
  <link href="http://mfrasier.github.io/"/>
  <updated>2014-12-03T21:12:16-05:00</updated>
  <id>http://mfrasier.github.io/</id>
  <author>
    <name><![CDATA[Marty Frasier]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Querying Elasticsearch]]></title>
    <link href="http://mfrasier.github.io/blog/2014/10/10/querying-elasticsearch/"/>
    <updated>2014-10-10T16:40:06-04:00</updated>
    <id>http://mfrasier.github.io/blog/2014/10/10/querying-elasticsearch</id>
    <content type="html"><![CDATA[<p>This post will begin our look at querying elasticsearch directly, via it&rsquo;s search API.  We&rsquo;ve looked at reporting and graphing tools like Kibana which provide some veneer over the actual queries.  Now we&rsquo;ll see what the queries and responses look like under the covers.</p>

<p>The first query we&rsquo;ll make will search an entire index with no filter provided - we will just dump the data content.</p>

<p>The API is accessible via an HTTP or HTTPS URI using the POST command.  There are many  search flavors available, documented in detail at the <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-search.html">elasticsearch search API</a>; we&rsquo;ll just touch the surface here.
The search API is accessible using a query parameter or request body.  The query parameter is limited but good for some testing so we&rsquo;ll use that first.</p>

<h4>The simplest search query ever &hellip;</h4>

<p>The URI structure to invoke the simplest elasticsearch query API looks like this:<br/>
<em>http(s)://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/_search</em></p>

<!-- more -->


<p>Using curl to invoke the simplest search query here is our response (truncated):</p>

<pre><code class="json">curl -XPOST http://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/_search

{
  "took": 56,
  "timed_out": false,
  "_shards": {
    "total": 16,
    "successful": 16,
    "failed": 0
  },
  "hits": {
    "total": 6559,
    "max_score": 1,
    "hits": [
      {
        "_index": "OUR-LOGSENE-APP-TOKEN_2014-10-04",
        "_type": "apache-access",
        "_id": "vfo3cnGFR5mU3Yyio_eG7w",
        "_score": 1,
        "_source": {
          "message": "223.151.106.187 - - [04/Oct/2014:01:40:50 +0000] \"CONNECT api.okcra.org:443 HTTP/1.1\" 404 137 \"-\" \"-\"",
          "@version": "1",
          "@timestamp": "2014-10-04T01:40:50.279Z",
          "type": "apache-access",
          "host": "ip-10-65-29-118",
          "path": "/var/log/httpd/api_okcra_ssl_access_log",
          "clientip": "223.151.106.187",
          "ident": "-",
          "auth": "-",
          "timestamp": "04/Oct/2014:01:40:50 +0000",
          "verb": "CONNECT",
          "request": "api.okcra.org:443",
          "httpversion": "1.1",
          "response": "404",
          "bytes": "137",
          "referrer": "\"-\"",
          "agent": "\"-\""
        }
      },
      ...
</code></pre>

<p>The response is pretty interesting.<br/>
The metadata at the beginning tells us the query took 56 ms across 16 shards and did not timeout.<br/>
The hits object is an array of objects, I&rsquo;ve truncated the list at one entry from default of 10 returned objects.  There were 6,559 entries that matched our search criteria.
The elements beginning with underscore were generated by elasticsearch when the entry was ingested.  Look, <em>_type == &lsquo;apache-access&rsquo;</em> - we&rsquo;ve seen that before!<br/>
The <em>_source</em> object is the most interesting as it is the JSON message sent from logstash.  The <em>message</em> field is the original log entry line.  The <em>type</em> field was assigned in the logstash input specification.  The other fields are values parsed from the apache combined log format by logstash prior to shipping the json-formatted log to elasticsearch.</p>

<p>You should be able to see how some of the pieces have come together now.  logstash configuration and parser (grok filter) transformed a raw apache log line into json-formatted data, sent it to elasticsearch where it was ingested, indexed by field, and made available over the network via an API for us and our applications to query.  Cool stuff indeed.</p>

<h4>Search within type(s)</h4>

<p>You can optionally add the record type to limit your search within that type.
For example, if we wished to search only within type apache-access we could use a URI like this:<br/>
<em>http(s)://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/<strong>apache-access</strong>/_search</em></p>

<p>You can add multiple types, by comma-separating them like this:<br/>
<em>http(s)://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/<strong>apache-access,syslog-cee</strong>/_search</em></p>

<h4>Search for records where a field equals some value</h4>

<p>Say, we want to find all apache access records where the http response code was a 400.  We could use a query like this:<br/>
<em>http(s)://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/apache-access/_search<strong>?response:400</strong></em></p>

<h4>A simple query body</h4>

<p>This is the same query as above but uses the Query DSL body<br/>
<em>http(s)://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/apache-access/_search <strong>-d &lsquo;{ &ldquo;query&rdquo; : { &ldquo;term&rdquo; : { &ldquo;response&rdquo; : &ldquo;400&rdquo;} }}&rsquo;</strong></em></p>

<p>DSL=Domain Specific Language so Query DSL is a language meant to describe queries in elasticsearch.  <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html">Elasticsearch Query DSL documentation</a></p>

<h4>Get a simple count</h4>

<p>There are lots of things we can do - one of which is simply count the number of records for a given type.  An excruciatingly simple example of using the Query DSL to count records of type apache-access might look something like this:<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -q -XPOST &lt;a href="http://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/apache-access/_count?pretty"&gt;http://logsene-receiver.sematext.com/OUR-LOGSENE-APP-TOKEN/apache-access/_count?pretty&lt;/a&gt; -d &lsquo;{
</span><span class='line'>  query: {
</span><span class='line'>    &ldquo;match_all&rdquo;: {}
</span><span class='line'>  }
</span><span class='line'>}&rsquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;{
</span><span class='line'>  &ldquo;count&rdquo;: 184,
</span><span class='line'>  &ldquo;_shards&rdquo;: {
</span><span class='line'>    &ldquo;total&rdquo;: 16,
</span><span class='line'>    &ldquo;successful&rdquo;: 16,
</span><span class='line'>    &ldquo;failed&rdquo;: 0
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
There are currently 184 such records.  Adding query parameter pretty told elasticsearch to pretty print the JSON response for easier consumption by humans.</p>
]]></content>
  </entry>
  
</feed>
